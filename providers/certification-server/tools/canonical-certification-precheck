#!/bin/bash

codename=$(/usr/bin/lsb_release -s -c) 
arch=$(dpkg --print-architecture)

pass(){
 eval pass${i}=1
}

fail(){
 eval pass${i}=0
}

warn(){
 eval pass${i}=2
}

info(){
 eval pass${i}=3
}



steps="Ubuntu_Version Arch EFI_Mode CCS_Version SID_Check Installed_Ram Virtualization_Support NICs_enabled IPERF Network_Subnets Hard_Disks USB_Disks KVM_Image_Check" 
yes=1

while getopts "i" opt; do
  case $opt in
    i) individual="1";;
  esac
done

echoname(){
    echo -e "\n\e[1;33m============\e[m \e[1;34m$name\e[m \e[1;33m============\e[m"
}

Arch(){
 name="Check architecture"
 echoname
 echo -e " Architecture: $arch"
 eval info${i}=\"$arch\"
 if [ $arch = i386 ] ; then
	 warn
 else
	 info
 fi
}


# Display version of canonical-certification-server package installed
CCS_Version(){
name="canonical-certification-server version"
echoname
ccs=$(apt-cache policy canonical-certification-server|grep Installed|awk '{print $2}')
eval info${i}=\"$ccs\"

if [[ $ccs = *none* ]] ; then
	echo -e " canonical-certification-server might not be installed.\n Would you like to install it now? [Y/n]"
	read -s -N1 a
   	if [[ $a == "Y" || $a == "y" || -z $a ]]; then
		echo " Installing canonical-certification-server..."
		sudo apt-add-repository -y ppa:hardware-certification/public 1>/dev/null
		sudo apt-get -q update 1>/dev/null
		sudo apt-get -q install -y canonical-certification-server 1>/dev/null
		CCS_Version
   	elif [[ $a == "N" || $a == "n" ]]; then
		echo 
		fail
	fi
else
	echo " canonical-certification-server: $ccs"
	info
fi
}

# Secure ID is set in /etc/xdg/canonical-certification.conf (?)
configure_SID(){
    read -e -p " Please enter the secure_id of your SUT: " sid 
    if grep "#secure_id" /etc/xdg/canonical-certification.conf >/dev/null ; then
        sudo sed -i "s/#\[transport:c3\]/\[transport:c3\]/g" /etc/xdg/canonical-certification.conf
	    sudo sed -i "s/#secure_id =.*/secure_id = $sid/g" /etc/xdg/canonical-certification.conf
    else
	    sudo sed -i "s/secure_id =.*/secure_id = $sid/g" /etc/xdg/canonical-certification.conf
    fi
}


SID_Check(){
name="Secure ID Check"
echoname
#if [ -n $secureid ];then
if grep "^secure_id =" /etc/xdg/canonical-certification.conf >/dev/null ; then
	secureid=$(grep "^secure_id =" /etc/xdg/canonical-certification.conf|awk '{print $3}')
    echo " Secure ID is configured as '$secureid'."
    echo " Is this correct? [Y/n]"
    read -s -N1 a
    if [[ $a == "n" || $a == "N" ]]; then
        configure_SID
        SID_Check
    else
	    eval info${i}=\"$secureid\"
        info
    fi
else
    echo -e " secure_id is not configured.\n Would you like to configure it now? [Y/n]"
    read -s -N1 a
    if [[ $a == "Y" || $a == "y" || -z $a ]]; then
        configure_SID
	    SID_Check
    elif [[ $a == "N" || $a == "n" ]]; then
		eval info${i}=\"Not Set\"
        info
    fi
fi
}

Hard_Disks(){
name="Hard Disk Filesystem Check"
echoname
local all_ok="Y"
local disk_UUIDs=()
local show_UUIDs="N"
local release_year="$(echo $DISTRIB_RELEASE | cut -f 1 -d ".")"
for disk in $(lsblk -r | grep disk | cut -f 1 -d " "); do
    local drive="/dev/$disk"
    # Suport for "-s PTUUID" in blkid was not present in Trusty, but does
    # exist in Xenial. Without that support, the PTUUID check produces false
    # alarms.
    if [ $release_year -gt 15 ]; then
        local UUID="$(sudo blkid -s PTUUID -o value $drive)"
        case "${disk_UUIDs[@]}" in
            $UUID) echo " Duplicate disk partition table GUID/UUID ($UUID)"
                echo " on $drive; possible multipath system!"
                show_UUIDs="Y"
                all_ok="N"
                ;;
        esac
        disk_UUIDs+=($UUID)
    fi
    if [ $(cat "/sys/block/$disk/removable") == "0" ]; then
        local fs="$(sudo blkid -s TYPE -o value /dev/$disk* | sort | uniq | tr '\n' ' ' | sed 's/,*$//g')"
        echo " Filesystem(s) detected on $drive: $fs"
        if [ -z "$(echo $fs | grep -E ext2\|ext3\|ext4\|xfs\|jfs\|btrfs)" ]; then
            if [ ! -z "$(echo $fs | grep LVM2_member)" ]; then
                fs_mapper="$(sudo blkid -s TYPE -o value /dev/mapper/* | sort | uniq | tr '\n' ' ' | sed 's/,*$//g')"
                echo " Filesystem(s) detected in /dev/mapper: $fs_mapper"
                if [ -z "$(echo $fs_mapper | grep -E ext2\|ext3\|ext4\|xfs\|jfs\|btrfs)" ]; then
                    echo " No suitable filesystem detected on $drive."
                    all_ok="N"
                fi
            else
                echo " No suitable filesystem detected on $drive."
                all_ok="N"
            fi
        fi
    fi
done
if [ "$show_UUIDs" == "Y" ]; then
    echo " Full partition table GUID/UUID ('PTUUID') information:"
    for disk in $(lsblk -r | grep disk | cut -f 1 -d " "); do
        echo "   $(sudo blkid -s PTUUID /dev/$disk)"
    done
fi
if [ "$all_ok" == "Y" ]; then
    pass
else
    fail
fi
}

USB_Disks(){
name="USB Disks Check"
echoname
local all_ok="Y"
local usb2_disks=()
local usb3_disks=()
for disk in $(lsblk -r | grep disk | cut -f 1 -d " "); do
    local drive="/dev/$disk"
    if [ $(cat "/sys/block/$disk/removable") == "1" ]; then
        local fs="$(sudo blkid -s TYPE -o value /dev/$disk* | sort | uniq | tr '\n' ',' | sed 's/,*$//g')"
        echo " Filesystem(s) detected on $drive: $fs"
        if [ "$fs" == "iso9660,vfat" ]; then
            echo " $drive may hold an Ubuntu installer, which is not suitable for certification"
            echo " testing."
            all_ok="N"
        elif [ -z "$(echo $fs | grep -E ext2\|ext3\|ext4\|xfs\|jfs\|btrfs\|vfat)" ]; then
            echo " No suitable filesystem detected on $drive."
            all_ok="N"
        fi
        path=$(readlink -f /sys/block/$disk)
        num_elements=$(echo $path | sed -n -e 's/usb[0-9].*//p' | sed 's/[^\/]//g' | awk '{ print length }')
        let hub_fields=$num_elements+1
        let device_fields=$num_elements+2
        hub_version=$(cat "$(echo $path | cut -d "/" -f 1-$hub_fields)/version" | tr -d " ")
        device_version=$(cat "$(echo $path | cut -d "/" -f 1-$device_fields)/version" | tr -d " ")
        if [ $(echo "$hub_version"'>='"3.0" | bc -l) == "1" ] && \
           [ $(echo "$device_version"'>='"3.0" | bc -l) == "1" ]; then
            usb3_disks+=($drive)
        elif [ $(echo "$hub_version"'>='"2.0" | bc -l) == "1" ] && \
             [ $(echo "$device_version"'>='"2.0" | bc -l) == "1" ]; then
            usb2_disks+=($drive)
        fi
    fi
done
if [ -z "$usb2_disks" ]; then
    echo " No USB2 disks detected."
    all_ok="N"
else
    echo " Detected USB2 disk(s): ${usb2_disks[*]}"
fi
if [ ! -z "$(lsusb | grep "3.0 root hub")" ]; then
    echo " Found USB 3.0 root hub"
    if [ -z "$usb3_disks" ]; then
        echo " No USB3 disks detected."
        all_ok="N"
    else
        echo " Detected USB3 disk(s): ${usb3_disks[*]}"
    fi
fi
if [ "$all_ok" == "Y" ]; then
    pass
else
    fail
fi
}

# Check local availability of KVM image or pull from Internet, which tends to be slow
KVM_Image_Check(){
name="KVM Image Check"
echoname
if grep "^KVM_IMAGE =" /etc/xdg/canonical-certification.conf >/dev/null; then
	kvmurl=$(grep ^KVM_IMAGE /etc/xdg/canonical-certification.conf|awk '{print $3}')
	/usr/bin/qemu-img check $kvmurl >/dev/null 2>&1
	if [ $? = "0" ]; then
 		echo -e " $kvmurl is a valid image.\n Continuing to use this image"
 		pass
		return 0
	else
		echo -e " $kvmurl is not a valid image.\n Would you like to reconfigure it now? [Y/n]"
         	read -s -N1 a
         	if [[ $a == "Y" || $a == "y" || -z $a ]]; then
               		read -e -p " Enter the path of your KVM Image: " kvm 
               		sudo sed -i "s,KVM_IMAGE =.*,KVM_IMAGE = $kvm,g" /etc/xdg/canonical-certification.conf
	 		kvmurl=$(grep ^KVM_IMAGE /etc/xdg/canonical-certification.conf|awk '{print $3}')
			/usr/bin/qemu-img check $kvmurl >/dev/null 2>&1
			if [ $? = "0" ]; then
 				echo -e " $kvmurl is a valid image.\n Continuing to use this image"
 				pass
				return 0
			else
 				echo -e " We cannot get our image from $kvmurl.\n Marking as failed."
				fail
				return 0
			fi
		else
			echo -e " Leaving configuration but commenting out.\n Trying cloud image."
			sudo sed -i '/^KVM_IMAGE/ s/^#*/#/' /etc/xdg/canonical-certification.conf
		fi
	fi

else
	echo -e " KVM_IMAGE is not configured.\n Note: If left unconfigured, we will pull our image from cloud-images.ubuntu.com.\n Would you like to configure it now? [Y/n]"
       	read -s -N1 a
       	if [[ $a == "Y" || $a == "y" || -z $a ]]; then
       		read -e -p " Enter the path of your KVM Image: " kvm 
       		sudo sed -i "s,#KVM_IMAGE =.*,KVM_IMAGE = $kvm,g" /etc/xdg/canonical-certification.conf
		kvmurl=$(grep ^KVM_IMAGE /etc/xdg/canonical-certification.conf|awk '{print $3}')
		/usr/bin/qemu-img check $kvmurl >/dev/null 2>&1
		if [ $? = "0" ]; then
 			echo -e " $kvmurl is a valid image.\n Continuing to use this image"
 			pass
			return 0
		else
			echo -e "\n $kvmurl is not a valid image.\n Would you like to reconfigure it now? [Y/n]"
         		read -s -N1 a
         		if [[ $a == "Y" || $a == "y" || -z $a ]]; then
               			read -e -p " Enter the path of your KVM Image: " kvm 
               			sudo sed -i "s,KVM_IMAGE =.*,KVM_IMAGE = $kvm,g" /etc/xdg/canonical-certification.conf
	 			kvmurl=$(grep ^KVM_IMAGE /etc/xdg/canonical-certification.conf|awk '{print $3}')
				/usr/bin/qemu-img check $kvmurl >/dev/null 2>&1
				if [ $? = "0" ]; then
 					echo -e " $kvmurl is a valid image.\n Continuing to use this image"
 					pass
					return 0
				else
					echo -e " Leaving configuration but commenting out.\n Trying cloud image."
					sudo sed -i '/^KVM_IMAGE/ s/^#*/#/' /etc/xdg/canonical-certification.conf
				fi
			else
				echo -e " Leaving configuration but commenting out.\n Trying cloud image."
				sudo sed -i '/^KVM_IMAGE/ s/^#*/#/' /etc/xdg/canonical-certification.conf
			fi
		fi
	fi
fi
kvmurl="http://cloud-images.ubuntu.com/$codename/current/$codename-server-cloudimg-$arch-disk1.img"
if curl --output /dev/null --silent --head -fail "$kvmurl"; then
 	echo -e " We can get our image from $kvmurl.\n Continuing to use this image"
		pass
	else
		echo -e " We cannot get our image from $kvmurl.\n Marking as failed"
		fail
	fi
}

#Correct Ubuntu version installed (could be tricky to determine, so maybe too much effort -- or maybe just display the Ubuntu version and, if the script is interactive, ask the user to verify that it’s what was intended)
Ubuntu_Version(){
 name="Ubuntu Version"
 echoname
 release=$(/usr/bin/lsb_release -s -d)
 eval info${i}=\"$release\"
 if [[ $release == *LTS* ]] ; then
        echo " $release is an LTS version of Ubuntu"
        info
 else
        echo " $release is a non-LTS version of Ubuntu"
        warn
 fi
}


# All NICs are on the same network segment, to flag cabling, switch, or configuration errors (??)
Network_Subnets(){
name="Network Subnets"
echoname
check_bcast=$(for nic in `cat /proc/net/dev|grep ":"|awk -F: '{print $1}'|egrep -v "lo|br.|tun.|usb."`
	do
		ip addr show dev $nic | grep "inet "|awk '{print $4}'
done|uniq|wc -l)
for nic in `cat /proc/net/dev|grep ":"|awk -F: '{print $1}'|egrep -v "lo|br.|tun.|usb."`
	do
		echo  " $nic - $(ip addr show dev $nic | grep "inet "|awk '{print $2, $4}')"
done
echo
if [ $check_bcast = 1 ]; then
	pass
	echo " All interfaces seem to be on the same subnet"
else
	echo " One or more interfaces are on separate subnets"
	fail
fi

}

# Check if iperf3 is available on server specified in /etc/xdg/canonical-certification.conf 
IPERF(){
name="Iperf"
echoname
if [ $(grep ^TEST_TARGET_IPERF /etc/xdg/canonical-certification.conf|wc -l) = 1 ];then
	echo " IPERF is configured"
	pass
elif [ $(grep ^TEST_TARGET_IPERF /etc/xdg/canonical-certification.conf|wc -l) = 0 ];then
	echo -e " TEST_TARGET_IPERF is not configured.\n Would you like to configure it now? [Y/n]"
	read -s -N1 a
   	if [[ $a == "Y" || $a == "y" || -z $a ]]; then
		read -e -p " Please enter the IP Address of the Iperf server: " ip
		sudo sed -i "s/#TEST_TARGET_IPERF = .*/TEST_TARGET_IPERF = $ip/g" /etc/xdg/canonical-certification.conf
	IPERF
   	elif [[ $a == "N" || $a == "n" ]]; then
		fail
	fi
fi
local iperf3found=0
for iperfserver in $(grep ^TEST_TARGET_IPERF /etc/xdg/canonical-certification.conf | cut -d = -f 2 | sed s/,/\\n/g)
        do
                iperf3 -c $iperfserver -n 1 >/dev/null 2>&1
                if [ $? = 0 ]; then
                        echo " Iperf3 server found on port 5201 on $iperfserver"
                        iperf3found=1
		else
                        echo " No Iperf3 server found on $iperfserver"
                fi
done
if [[ $iperf3found == 0 ]]; then
        echo " No iperf3 server found"
        fail
else
	pass
fi
}

# All NICs are enabled and set to maximum speed
NICs_enabled(){
name="All NICs enabled and at maximum supported speed"
echoname
local worst_status=0
for nic in `cat /proc/net/dev|grep ":"|awk -F: '{print $1}'|egrep -v "lo|br.|tun.|usb."`; do
    local state=$(cat /sys/class/net/$nic/operstate)
    # /sys/class/net/wlan0/speed produces an error and returns nothing,
    # so protect against this as a special case.
    local current_speed=$(cat /sys/class/net/$nic/speed 2> /dev/null)
    if [ -z "$current_speed" ]; then
        current_speed=0
    fi
    local max_speed=0
    # current_speed (above) and speed (below) are computed in the same way here as
    # in the "network" Checkbox script (give or take bash vs. Python differences).
    # If one is changed, the other should be, too.
    for speed in $(ethtool $nic 2> /dev/null | egrep '[[:digit:]](base)([A-Z]+)|[[:digit:]](Mb/s)' | \
                   sed 's/[^0-9 ]*//g' | tr " " "\n" | sort | uniq | sed '/^\s*$/d'); do
        if [ $speed -ge $max_speed ]; then
            max_speed="$speed"
        fi
    done
    echo -n " Interface $nic is $state"
    if [ "$state" != "down" ]; then
        echo -n " and running at $current_speed of $max_speed Mbps"
    fi
    if [ $current_speed -gt 0 ] && [ $current_speed -ge $max_speed ] && [ "$state" == "up" ]; then
        echo "; config is OK"
    elif ([ $current_speed -eq 0 ] && [ "$state" == "up" ]) || [ "$state" == "unknown" ]; then
        echo "; config is UNKNOWN"
        let worst_status=$(($worst_status | 1))
    else
        echo "; config is BAD"
        let worst_status=$(($worst_status | 2))
    fi
done
case "$worst_status" in
    0) pass
        ;;
    1) eval info${i}=\"Unknown config\"
        warn
        ;;
    *) fail
        ;;
esac
}

#### Installed RAM (STG says 4GiB minimum) ###
Installed_Ram(){
name="Check Installed Ram"
echoname
mem=$(cat /proc/meminfo |grep MemTotal|awk '{print $2}')
eval info${i}="$mem "
if [ $mem -lt 4096000 ] ; then
	echo " $mem is less than 4G"
	warn
else
	echo " $mem is greater than 4G"
	pass
fi
}

#CPU virtualization support (VMX/SVM)
Virtualization_Support(){
name="Virtualization Support"
echoname
/usr/sbin/kvm-ok >/dev/null
if [ $? = 0 ]; then
 echo " System has virtualization support"
 pass
else
 echo " System does NOT have virtualization support"
 fail
fi
}

#EFI-mode installation (redundant with Checkbox test for same, but maybe good to warn about this issue before running Checkbox)
EFI_Mode(){
name="EFI-mode installation"
echoname
if [ -d /sys/firmware/efi ]; then
	efi='This is an EFI Mode installation'
	echo " $efi"
	eval info${i}=\"$efi\"
	info
elif [ ! -d /sys/firmware/efi ]; then
	efi='This is not an EFI Mode installation'
	echo " $efi"
	eval info${i}=\"$efi\"
	info
fi
}

runchoices() {
 echo 
 for i in $steps
  do
   eval "status=\$check${i}"
   if [[ $status == "y" ]] || [[ "$yes" == "1" ]]; then
    "$i"
   else
    echo -e "\e[1;31mskipping\e[m \e[1;34m$i\e[m"
   fi
 done
}

report() {
    echo -e "\n\e[1;33m============\e[m \e[1;34mReport\e[m \e[1;33m============\e[m\n"
 for i in $steps
  do
   eval "status=\$pass${i}"
   if [ $status = "1" ];then
    printf "%30s" "$i  "
    printf "%0.1s" "-"{1..20}
    printf "\e[1;32m  Passed\e[m\n"
   elif [ $status = "0" ];then
    printf "%30s" "$i  "
    printf "%0.1s" "-"{1..20}
    printf "\e[1;31m  Failed\e[m\n"
   elif [ $status = "2" ];then
    eval "detail=\$info${i}"
    printf "%30s" "$i  "
    printf "%0.1s" "-"{1..20}
    printf "\e[1;33m  $detail\e[m\n"
   elif [ $status = "3" ];then
    eval "detail=\$info${i}"
    printf "%30s" "$i  "
    printf "%0.1s" "-"{1..20}
    printf "\e[1;37m  $detail\e[m\n"
   fi
 done
}

. /etc/lsb-release

runchoices
report
